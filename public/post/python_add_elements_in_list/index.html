<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.53" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Fanjingbo" />
  <meta property="og:url" content="https://fanjingbo.com/post/python_add_elements_in_list/" />
  <link rel="canonical" href="https://fanjingbo.com/post/python_add_elements_in_list/" />
  <link rel="shortcut icon" href="https://fanjingbo.com/logo.png" type="image/x-png" />

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https://fanjingbo.com"
      },
      "articleSection" : "post",
      "name" : "Python中list增加元素的几种方法",
      "headline" : "Python中list增加元素的几种方法",
      "description" : "一 我一般会用append方法来把元素增加到list中.但今天我看到一种新方法：
a = [1] a += 2, # a = [1, 2]  感觉挺神奇的，所以我查了一些资料，总结如下.
二 1.元组 上面的2,代表了单元素元组(one element tuple).在元组的表达式中，逗号是必需的，括号则可要可不要.对于单元素元组来说，后面的逗号必须有；而对于多元素元组，只要中间有逗号即可.
1, 1,2,3  2.a+=b和a=a+b的区别 a+=b
&gt;&gt;&gt; a = [1] &gt;&gt;&gt; b = a &gt;&gt;&gt; b += [2] &gt;&gt;&gt; a [1, 2] &gt;&gt;&gt; b [1, 2]  a=a+b
&gt;&gt;&gt; b = a &gt;&gt;&gt; b = b + [2] &gt;&gt;&gt; a [1] &gt;&gt;&gt; b [1, 2]  对于可变对象，+=操作调用iadd方法，直接在原对象a上进行更新，该方法的返回值是None；+操作调用add方法，返回一个新的对象，原对象不修改，所以b被重新赋值，b指向了一个新的对象.
对于不可变对象，只有add方法，所以两者效果一样.
不仅如此，在list增加元素方面，两者也有不同.
&gt;&gt;&gt; a = [] &gt;&gt;&gt; a = a + 1 Traceback (most recent call last): File &quot;&amp;lt;stdin&gt;&quot;, line 1, in &amp;lt;module&gt; TypeError: can only concatenate list (not &quot;int&quot;) to list &gt;&gt;&gt; a = a + (1,) Traceback (most recent call last): File &quot;&amp;lt;stdin&gt;&quot;, line 1, in &amp;lt;module&gt; TypeError: can only concatenate list (not &quot;tuple&quot;) to list &gt;&gt;&gt; a = a + [1] &gt;&gt;&gt; a [1]  &gt;&gt;&gt; a += 1, &gt;&gt;&gt; a += [1] &gt;&gt;&gt; a += 1 Traceback (most recent call last): File &quot;&amp;lt;stdin&gt;&quot;, line 1, in &amp;lt;module&gt; TypeError: 'int' object is not iterable  可以看出对于a+=b，b只要是iterable即可；而对于a=a+b，b必须是list类型.",
      "inLanguage" : "en-US",
      "author" : "Fanjingbo",
      "creator" : "Fanjingbo",
      "publisher": "Fanjingbo",
      "accountablePerson" : "Fanjingbo",
      "copyrightHolder" : "Fanjingbo",
      "copyrightYear" : "2017",
      "datePublished": "2017-11-30 07:51:59 &#43;0800 CST",
      "dateModified" : "2017-11-30 07:51:59 &#43;0800 CST",
      "url" : "https://fanjingbo.com/post/python_add_elements_in_list/",
      "keywords" : [  ]
  }
</script>
<title>Python中list增加元素的几种方法 - Fan Jingbo&#39;s Blog</title>
  <meta property="og:title" content="Python中list增加元素的几种方法 - Fan Jingbo&#39;s Blog" />
  <meta property="og:type" content="article" />
  <meta name="description" content="一 我一般会用append方法来把元素增加到list中.但今天我看到一种新方法：
a = [1] a &#43;= 2, # a = [1, 2]  感觉挺神奇的，所以我查了一些资料，总结如下.
二 1.元组 上面的2,代表了单元素元组(one element tuple).在元组的表达式中，逗号是必需的，括号则可要可不要.对于单元素元组来说，后面的逗号必须有；而对于多元素元组，只要中间有逗号即可.
1, 1,2,3  2.a&#43;=b和a=a&#43;b的区别 a&#43;=b
&gt;&gt;&gt; a = [1] &gt;&gt;&gt; b = a &gt;&gt;&gt; b &#43;= [2] &gt;&gt;&gt; a [1, 2] &gt;&gt;&gt; b [1, 2]  a=a&#43;b
&gt;&gt;&gt; b = a &gt;&gt;&gt; b = b &#43; [2] &gt;&gt;&gt; a [1] &gt;&gt;&gt; b [1, 2]  对于可变对象，&#43;=操作调用iadd方法，直接在原对象a上进行更新，该方法的返回值是None；&#43;操作调用add方法，返回一个新的对象，原对象不修改，所以b被重新赋值，b指向了一个新的对象.
对于不可变对象，只有add方法，所以两者效果一样.
不仅如此，在list增加元素方面，两者也有不同.
&gt;&gt;&gt; a = [] &gt;&gt;&gt; a = a &#43; 1 Traceback (most recent call last): File &quot;&amp;lt;stdin&gt;&quot;, line 1, in &amp;lt;module&gt; TypeError: can only concatenate list (not &quot;int&quot;) to list &gt;&gt;&gt; a = a &#43; (1,) Traceback (most recent call last): File &quot;&amp;lt;stdin&gt;&quot;, line 1, in &amp;lt;module&gt; TypeError: can only concatenate list (not &quot;tuple&quot;) to list &gt;&gt;&gt; a = a &#43; [1] &gt;&gt;&gt; a [1]  &gt;&gt;&gt; a &#43;= 1, &gt;&gt;&gt; a &#43;= [1] &gt;&gt;&gt; a &#43;= 1 Traceback (most recent call last): File &quot;&amp;lt;stdin&gt;&quot;, line 1, in &amp;lt;module&gt; TypeError: &#39;int&#39; object is not iterable  可以看出对于a&#43;=b，b只要是iterable即可；而对于a=a&#43;b，b必须是list类型." />

  <link
    rel="stylesheet"
    href="https://lib.baomitu.com/flexboxgrid/6.3.1/flexboxgrid.min.css"
  />
  <link
    rel="stylesheet"
    href="https://lib.baomitu.com/github-markdown-css/2.10.0/github-markdown.min.css"
  />
  <link
    rel="stylesheet"
    href="https://lib.baomitu.com/highlight.js/9.13.1/styles/tomorrow.min.css"
  />
  <link rel="stylesheet" href="/css/index.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="Fan Jingbo&#39;s Blog">
  
  <script>
    

    (function(undefined) {}).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});
  </script>

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-132076423-1"></script><script src="https://fanjingbo.com/analytics.js"></script>
</head>


  <body>
    <article class="post Chinese" id="article">
      <div class="row">
        <div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3">
          <a href="/">
            <div class="head-line"></div>
          </a>
          <header class="post-header">
            <h1 class="post-title">Python中list增加元素的几种方法</h1>
            <div class="row">
              <div class="col-xs-6">
                <time class="post-date" datetime="2017-11-30 07:51:59 CST">
                  30 Nov 2017
                </time>
              </div>
              <div class="col-xs-6">
                <div class="post-author">
                  <a target="_blank" href="https://fanjingbo.com">@Fanjingbo</a>
                </div>
              </div>
            </div>
          </header>
    
          <div class="post-content markdown-body">
            

<h2 id="一">一</h2>

<p>我一般会用append方法来把元素增加到list中.但今天我看到一种新方法：</p>

<pre><code class="language-python">a = [1]
a += 2,
# a = [1, 2]
</code></pre>

<p>感觉挺神奇的，所以我查了一些资料，总结如下.</p>

<h2 id="二">二</h2>

<h3 id="1-元组">1.元组</h3>

<p>上面的2,代表了单元素元组(one element tuple).在元组的表达式中，逗号是必需的，括号则可要可不要.对于单元素元组来说，后面的逗号必须有；而对于多元素元组，只要中间有逗号即可.</p>

<pre><code class="language-python">1,
1,2,3
</code></pre>

<h3 id="2-a-b和a-a-b的区别">2.a+=b和a=a+b的区别</h3>

<p>a+=b</p>

<pre><code class="language-python">&gt;&gt;&gt; a = [1]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b += [2]
&gt;&gt;&gt; a
[1, 2]
&gt;&gt;&gt; b
[1, 2]
</code></pre>

<p>a=a+b</p>

<pre><code class="language-python&gt;&gt;&gt;">&gt;&gt;&gt; b = a
&gt;&gt;&gt; b = b + [2]
&gt;&gt;&gt; a
[1]
&gt;&gt;&gt; b
[1, 2]
</code></pre>

<p>对于可变对象，+=操作调用<strong>iadd</strong>方法，直接在原对象a上进行更新，该方法的返回值是None；+操作调用<strong>add</strong>方法，返回一个新的对象，原对象不修改，所以b被重新赋值，b指向了一个新的对象.</p>

<p>对于不可变对象，只有<strong>add</strong>方法，所以两者效果一样.</p>

<p>不仅如此，在list增加元素方面，两者也有不同.</p>

<pre><code class="language-python">&gt;&gt;&gt; a = []
&gt;&gt;&gt; a = a + 1
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&gt;&quot;, line 1, in &amp;lt;module&gt;
TypeError: can only concatenate list (not &quot;int&quot;) to list
&gt;&gt;&gt; a = a + (1,)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&gt;&quot;, line 1, in &amp;lt;module&gt;
TypeError: can only concatenate list (not &quot;tuple&quot;) to list
&gt;&gt;&gt; a = a + [1]
&gt;&gt;&gt; a
[1]
</code></pre>

<pre><code class="language-python&gt;&gt;&gt;">&gt;&gt;&gt; a += 1,
&gt;&gt;&gt; a += [1]
&gt;&gt;&gt; a += 1
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&gt;&quot;, line 1, in &amp;lt;module&gt;
TypeError: 'int' object is not iterable
</code></pre>

<p>可以看出对于a+=b，b只要是iterable即可；而对于a=a+b，b必须是list类型.其中的原因，可能是<strong>iadd</strong>和<strong>add</strong>方法实现有差异，这里就不做深究了.</p>

<h3 id="3-list增加元素几种方法的速度对比">3.list增加元素几种方法的速度对比</h3>

<p>原本我在一个Python文件里写几种方法的实现函数，然后调用timeit模块逐个运行，但是发现无论顺序如何，第一个方法总是时间偏长，不知道原因在哪.所以为了避免这种误差，使用python -m timeit &lsquo;(CODE)&lsquo;分别运行，结果如下</p>

<pre><code class="language-python">&gt;&gt;&gt; python -m timeit 'a=[];a.insert(0,[1])'
1000000 loops, best of 3: 0.354 usec per loop
&gt;&gt;&gt; python -m timeit 'a=[];a.extend([1])'
1000000 loops, best of 3: 0.228 usec per loop
&gt;&gt;&gt; python -m timeit 'a=[];a.append(1)'
10000000 loops, best of 3: 0.153 usec per loop
&gt;&gt;&gt; python -m timeit 'a=[];a+=[1]'
10000000 loops, best of 3: 0.149 usec per loop
&gt;&gt;&gt; python -m timeit 'a=[];a+=1,'
10000000 loops, best of 3: 0.101 usec per loop
</code></pre>

<p>insert和extend这两种方法不是专门为list增加元素设计的，所以用时较长.append方法和加list时间相近，但是append只适用于一个一个元素的增加，而加list可以一次增加多个元素.加tuple是其中最快的.</p>

<p>考虑加list和加tuple两种方法的时间差异可能存在于list和tuple的定义中，所以进一步实验如下：</p>

<pre><code class="language-python">&gt;&gt;&gt; python -m timeit 'a=[1]'
10000000 loops, best of 3: 0.069 usec per loop
&gt;&gt;&gt; python -m timeit 'a=1,'
10000000 loops, best of 3: 0.0214 usec per loop
</code></pre>

<p>果然不出所料，tuple定义比list快，直接导致了加tuple比加list快.</p>

          </div>
          
          
          <div class="post-comments">
            <div id="disqus_thread"></div>
<script>
  window.addEventListener("load", () => {
    (function() {
      
      var d = document,
        s = d.createElement("script");
      s.src = "https://fanjingbo-com.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  });
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>

          </div>
          
        </div>
      </div>
    </article>

    <script src="/js/highlight.pack.js"></script>


<script>
  hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });
</script>

    

  </body>
</html>
