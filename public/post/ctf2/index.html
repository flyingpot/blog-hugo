<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Fan Jingbo"><meta property="og:url" content="https://fanjingbo.com/post/ctf2/"><link rel=canonical href=https://fanjingbo.com/post/ctf2/><link rel=preload href=/js/highlight.pack.js as=script><link rel=alternate type=application/atom+xml href=https://fanjingbo.comindex.xml title="Fan Jingbo's Blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/fanjingbo.com"},"articleSection":"post","name":"CTF从零单排（二）—— bof (pwnable.kr)","headline":"CTF从零单排（二）—— bof (pwnable.kr)","description":"一、题目分析 查看题目给出的信息，一个C代码文件和一个可执行文件，C代码文件如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void func(int key){ char overflowme[32]; printf(\u0026quot;overflow me : \u0026quot;); gets(overflowme);\t\/\/ smash me! if(key == 0xcafebabe){ system(\u0026quot;\/bin\/sh\u0026quot;); } else{ printf(\u0026quot;Nah..\\n\u0026quot;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; }  可以看出这道题考的是栈溢出，从标准输入读取的数据覆盖掉func传入的参数值即可提权。关键问题就是如何构造这个数据。\n二、题解 使用gdb对可执行文件bof进行分析：\n首先使用start开始执行，方便之后使用地址打断点\n然后使用disas func查看func函数的汇编代码\n找到get函数调用后的比较语句并打断点\n使用c（continue）继续执行代码\n输入AAAAAA，使用x \/40xw $esp查看栈数据。A用16进制表示是41，可以看到第一个A到deadbeef相差52个字节。因此我们只需要构造52个A加上cafebabe即可。\n使用Python的pwn库：\n成功拿到flag\n由此可见，C代码中使用gets有多危险，使用gcc编译时也会提示gets的危险性。\n三、遗留问题 虽然题目参考着其他人的题解做了出来，但是目前还是有两个问题我还没想明白，在这里记录一下：\n  发现如果使用gcc默认编译选项编译出来的可执行文件（可能与64位有关），deadbeef参数在低地址，标准输入参数在高地址，不符合栈帧是从高地址向低地址生长（申请）的原则，很奇怪\n  为什么0xdeadbeef写入栈中的时候没有按照小端原则？\n问题已解决，因为0xdeadbeef是int类型，占据了4个字节，所以无所谓大端小端，在内存中就是以0xdeadbeef形式保存的\n  ","inLanguage":"en-US","author":"Fan Jingbo","creator":"Fan Jingbo","publisher":"Fan Jingbo","accountablePerson":"Fan Jingbo","copyrightHolder":"Fan Jingbo","copyrightYear":"2020","datePublished":"2020-08-15 16:00:00 \u002b0000 UTC","dateModified":"2020-08-15 16:00:00 \u002b0000 UTC","url":"https:\/\/fanjingbo.com\/post\/ctf2\/","keywords":[]}</script><title>CTF从零单排（二）—— bof (pwnable.kr) - Fan Jingbo's Blog</title><meta property="og:title" content="CTF从零单排（二）—— bof (pwnable.kr) - Fan Jingbo's Blog"><meta property="og:type" content="article"><meta property="og:description" content="一、题目分析 查看题目给出的信息，一个C代码文件和一个可执行文件，C代码文件如下：
#include <stdio.h> #include <string.h> #include <stdlib.h> void func(int key){ char overflowme[32]; printf(&#34;overflow me : &#34;); gets(overflowme);	// smash me! if(key == 0xcafebabe){ system(&#34;/bin/sh&#34;); } else{ printf(&#34;Nah..\n&#34;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; }  可以看出这道题考的是栈溢出，从标准输入读取的数据覆盖掉func传入的参数值即可提权。关键问题就是如何构造这个数据。
二、题解 使用gdb对可执行文件bof进行分析：
首先使用start开始执行，方便之后使用地址打断点
然后使用disas func查看func函数的汇编代码
找到get函数调用后的比较语句并打断点
使用c（continue）继续执行代码
输入AAAAAA，使用x /40xw $esp查看栈数据。A用16进制表示是41，可以看到第一个A到deadbeef相差52个字节。因此我们只需要构造52个A加上cafebabe即可。
使用Python的pwn库：
成功拿到flag
由此可见，C代码中使用gets有多危险，使用gcc编译时也会提示gets的危险性。
三、遗留问题 虽然题目参考着其他人的题解做了出来，但是目前还是有两个问题我还没想明白，在这里记录一下：
  发现如果使用gcc默认编译选项编译出来的可执行文件（可能与64位有关），deadbeef参数在低地址，标准输入参数在高地址，不符合栈帧是从高地址向低地址生长（申请）的原则，很奇怪
  为什么0xdeadbeef写入栈中的时候没有按照小端原则？
问题已解决，因为0xdeadbeef是int类型，占据了4个字节，所以无所谓大端小端，在内存中就是以0xdeadbeef形式保存的
  "><meta name=description content="一、题目分析 查看题目给出的信息，一个C代码文件和一个可执行文件，C代码文件如下：
#include <stdio.h> #include <string.h> #include <stdlib.h> void func(int key){ char overflowme[32]; printf(&#34;overflow me : &#34;); gets(overflowme);	// smash me! if(key == 0xcafebabe){ system(&#34;/bin/sh&#34;); } else{ printf(&#34;Nah..\n&#34;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; }  可以看出这道题考的是栈溢出，从标准输入读取的数据覆盖掉func传入的参数值即可提权。关键问题就是如何构造这个数据。
二、题解 使用gdb对可执行文件bof进行分析：
首先使用start开始执行，方便之后使用地址打断点
然后使用disas func查看func函数的汇编代码
找到get函数调用后的比较语句并打断点
使用c（continue）继续执行代码
输入AAAAAA，使用x /40xw $esp查看栈数据。A用16进制表示是41，可以看到第一个A到deadbeef相差52个字节。因此我们只需要构造52个A加上cafebabe即可。
使用Python的pwn库：
成功拿到flag
由此可见，C代码中使用gets有多危险，使用gcc编译时也会提示gets的危险性。
三、遗留问题 虽然题目参考着其他人的题解做了出来，但是目前还是有两个问题我还没想明白，在这里记录一下：
  发现如果使用gcc默认编译选项编译出来的可执行文件（可能与64位有关），deadbeef参数在低地址，标准输入参数在高地址，不符合栈帧是从高地址向低地址生长（申请）的原则，很奇怪
  为什么0xdeadbeef写入栈中的时候没有按照小端原则？
问题已解决，因为0xdeadbeef是int类型，占据了4个字节，所以无所谓大端小端，在内存中就是以0xdeadbeef形式保存的
  "><meta property="og:locale" content="en-us"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Fan Jingbo's Blog"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif&display=swap" rel=stylesheet></head><body><article class="post Chinese" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Fan Jingbo</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>CTF从零单排（二）—— bof (pwnable.kr)</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2020-08-15 16:00:00 UTC">15 Aug 2020</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://fanjingbo.com>@Fan Jingbo</a></div></div></div></header><div class="post-content markdown-body"><h1 id=一题目分析>一、题目分析</h1><p>查看题目给出的信息，一个C代码文件和一个可执行文件，C代码文件如下：</p><pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
void func(int key){
	char overflowme[32];
	printf(&quot;overflow me : &quot;);
	gets(overflowme);	// smash me!
	if(key == 0xcafebabe){
        system(&quot;/bin/sh&quot;);
	}
	else{
        printf(&quot;Nah..\n&quot;);
	}
}
int main(int argc, char* argv[]){
	func(0xdeadbeef);
	return 0;
}
</code></pre><p>可以看出这道题考的是栈溢出，从标准输入读取的数据覆盖掉func传入的参数值即可提权。关键问题就是如何构造这个数据。</p><h2 id=二题解>二、题解</h2><p>使用gdb对可执行文件bof进行分析：</p><p>首先使用start开始执行，方便之后使用地址打断点</p><p>然后使用disas func查看func函数的汇编代码</p><p>找到get函数调用后的比较语句并打断点</p><p>使用c（continue）继续执行代码</p><p>输入AAAAAA，使用x /40xw $esp查看栈数据。A用16进制表示是41，可以看到第一个A到deadbeef相差52个字节。因此我们只需要构造52个A加上cafebabe即可。</p><p>使用Python的pwn库：</p><p>成功拿到flag</p><p>由此可见，C代码中使用gets有多危险，使用gcc编译时也会提示gets的危险性。</p><h2 id=三遗留问题>三、遗留问题</h2><p>虽然题目参考着其他人的题解做了出来，但是目前还是有两个问题我还没想明白，在这里记录一下：</p><ol><li><p>发现如果使用gcc默认编译选项编译出来的可执行文件（可能与64位有关），deadbeef参数在低地址，标准输入参数在高地址，不符合栈帧是从高地址向低地址生长（申请）的原则，很奇怪</p></li><li><p>为什么0xdeadbeef写入栈中的时候没有按照小端原则？</p><p>问题已解决，因为0xdeadbeef是int类型，占据了4个字节，所以无所谓大端小端，在内存中就是以0xdeadbeef形式保存的</p></li></ol></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=site-footer><div class=site-footer-item><a href=http://beian.miit.gov.cn target=_blank>粤ICP备18020202号-1</a></div><div class=site-footer-item><a href=https://github.com/flyingpot target=_blank>Github</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad()</script></body></html>