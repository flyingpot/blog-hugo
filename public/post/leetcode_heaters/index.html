<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.53" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Fanjingbo" />
  <meta property="og:url" content="https://fanjingbo.com/post/leetcode_heaters/" />
  <link rel="canonical" href="https://fanjingbo.com/post/leetcode_heaters/" />
  <link rel="shortcut icon" href="https://fanjingbo.com/logo.png" type="image/x-png" />

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https://fanjingbo.com"
      },
      "articleSection" : "post",
      "name" : "[Leetcode] Heaters",
      "headline" : "[Leetcode] Heaters",
      "description" : " 一、题目描述 链接
二、题目分析 有两个数组，一个数组代表house位置，另一个代表heater位置。这种类型题一般来说都是固定一个数组，遍历另一个数组。固定house，遍历heater明显不对。因为heater的相互位置没有考虑，结果一定偏大。以下图为例，两个数组分别为：[0, 3], [1, 2]，如果分别遍历1和2，则结果至少是2，实际应该是1.所以应该固定heater，遍历house。
思路确定之后，解法就很明显了。解法一：对每个house位置，用二分法找到最近的heater位置，最后取位置的最大值即为解，因为用了二分法，所以heater数组需要先进行排序。解法二：把house和heater两个数组都进行排序，然后遍历house，每次记住最近的heater位置，下次遍历时从记住的位置开始，最后取位置最大值为解。
三、代码 解法一： heaters.sort() res = 0 for house in houses: start = 0 end = len(heaters) - 1 while start + 1 &amp;lt; end: mid = start + (end - start) / 2 if heaters[mid] &gt; house: end = mid else: start = mid res = max(res, min(abs(house - heaters[start]), abs(heaters[end] - house))) return res  解法二： houses.sort() heaters.sort() i, res = 0, 0 for house in houses: while i &amp;lt; len(heaters) - 1 and heaters[i] + heaters[i + 1] &amp;lt;= house * 2: i += 1 res = max(res, abs(heaters[i] - house)) return res  ",
      "inLanguage" : "en-US",
      "author" : "Fanjingbo",
      "creator" : "Fanjingbo",
      "publisher": "Fanjingbo",
      "accountablePerson" : "Fanjingbo",
      "copyrightHolder" : "Fanjingbo",
      "copyrightYear" : "2018",
      "datePublished": "2018-02-05 01:44:15 &#43;0800 CST",
      "dateModified" : "2018-02-05 01:44:15 &#43;0800 CST",
      "url" : "https://fanjingbo.com/post/leetcode_heaters/",
      "keywords" : [  ]
  }
</script>
<title>[Leetcode] Heaters - Fan Jingbo&#39;s Blog</title>
  <meta property="og:title" content="[Leetcode] Heaters - Fan Jingbo&#39;s Blog" />
  <meta property="og:type" content="article" />
  <meta name="description" content=" 一、题目描述 链接
二、题目分析 有两个数组，一个数组代表house位置，另一个代表heater位置。这种类型题一般来说都是固定一个数组，遍历另一个数组。固定house，遍历heater明显不对。因为heater的相互位置没有考虑，结果一定偏大。以下图为例，两个数组分别为：[0, 3], [1, 2]，如果分别遍历1和2，则结果至少是2，实际应该是1.所以应该固定heater，遍历house。
思路确定之后，解法就很明显了。解法一：对每个house位置，用二分法找到最近的heater位置，最后取位置的最大值即为解，因为用了二分法，所以heater数组需要先进行排序。解法二：把house和heater两个数组都进行排序，然后遍历house，每次记住最近的heater位置，下次遍历时从记住的位置开始，最后取位置最大值为解。
三、代码 解法一： heaters.sort() res = 0 for house in houses: start = 0 end = len(heaters) - 1 while start &#43; 1 &amp;lt; end: mid = start &#43; (end - start) / 2 if heaters[mid] &gt; house: end = mid else: start = mid res = max(res, min(abs(house - heaters[start]), abs(heaters[end] - house))) return res  解法二： houses.sort() heaters.sort() i, res = 0, 0 for house in houses: while i &amp;lt; len(heaters) - 1 and heaters[i] &#43; heaters[i &#43; 1] &amp;lt;= house * 2: i &#43;= 1 res = max(res, abs(heaters[i] - house)) return res  " />

  <link
    rel="stylesheet"
    href="https://lib.baomitu.com/flexboxgrid/6.3.1/flexboxgrid.min.css"
  />
  <link
    rel="stylesheet"
    href="https://lib.baomitu.com/github-markdown-css/2.10.0/github-markdown.min.css"
  />
  <link
    rel="stylesheet"
    href="https://lib.baomitu.com/highlight.js/9.13.1/styles/tomorrow.min.css"
  />
  <link rel="stylesheet" href="/css/index.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="Fan Jingbo&#39;s Blog">
  
  <script>
    

    (function(undefined) {}).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});
  </script>

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-132076423-1"></script><script src="https://fanjingbo.com/analytics.js"></script>
</head>


  <body>
    <article class="post Chinese" id="article">
      <div class="row">
        <div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3">
          <a href="/">
            <div class="head-line"></div>
          </a>
          <header class="post-header">
            <h1 class="post-title">[Leetcode] Heaters</h1>
            <div class="row">
              <div class="col-xs-6">
                <time class="post-date" datetime="2018-02-05 01:44:15 CST">
                  05 Feb 2018
                </time>
              </div>
              <div class="col-xs-6">
                <div class="post-author">
                  <a target="_blank" href="https://fanjingbo.com">@Fanjingbo</a>
                </div>
              </div>
            </div>
          </header>
    
          <div class="post-content markdown-body">
            

<h2 id="一-题目描述">一、题目描述</h2>

<p><a href="https://leetcode.com/problems/heaters/description/">链接</a></p>

<h2 id="二-题目分析">二、题目分析</h2>

<p>有两个数组，一个数组代表house位置，另一个代表heater位置。这种类型题一般来说都是<strong>固定一个数组，遍历另一个数组</strong>。固定house，遍历heater明显不对。因为heater的相互位置没有考虑，结果一定偏大。以下图为例，两个数组分别为：[0, 3], [1, 2]，如果分别遍历1和2，则结果至少是2，实际应该是1.所以应该固定heater，遍历house。</p>

<p>思路确定之后，解法就很明显了。解法一：对每个house位置，用二分法找到最近的heater位置，最后取位置的最大值即为解，因为用了二分法，所以heater数组需要先进行排序。解法二：把house和heater两个数组都进行排序，然后遍历house，每次记住最近的heater位置，下次遍历时从记住的位置开始，最后取位置最大值为解。</p>

<h2 id="三-代码">三、代码</h2>

<h3 id="解法一">解法一：</h3>

<pre><code class="language-python">heaters.sort()
res = 0
for house in houses:
    start = 0
    end = len(heaters) - 1
    while start + 1 &amp;lt; end:
        mid = start + (end - start) / 2
        if heaters[mid] &gt; house:
            end = mid
        else:
            start = mid
    res = max(res, min(abs(house - heaters[start]), abs(heaters[end] - house)))
return res
</code></pre>

<h3 id="解法二">解法二：</h3>

<pre><code class="language-python">houses.sort()
heaters.sort()
i, res = 0, 0
for house in houses:
    while i &amp;lt; len(heaters) - 1 and heaters[i] + heaters[i + 1] &amp;lt;= house * 2:
        i += 1
    res = max(res, abs(heaters[i] - house))
return res
</code></pre>

          </div>
          
          
          <div class="post-comments">
            <div id="disqus_thread"></div>
<script>
  window.addEventListener("load", () => {
    (function() {
      
      var d = document,
        s = d.createElement("script");
      s.src = "https://fanjingbo-com.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  });
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>

          </div>
          
        </div>
      </div>
    </article>

    <script src="/js/highlight.pack.js"></script>


<script>
  hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });
</script>

    

  </body>
</html>
