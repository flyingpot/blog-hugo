<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Fan Jingbo"><meta property="og:url" content="https://fanjingbo.com/post/leetcode_heaters/"><link rel=canonical href=https://fanjingbo.com/post/leetcode_heaters/><link rel=preload href=/js/highlight.pack.js as=script><link rel=alternate type=application/atom+xml href=https://fanjingbo.comindex.xml title="Fan Jingbo's Blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/fanjingbo.com"},"articleSection":"post","name":"[Leetcode] Heaters","headline":"[Leetcode] Heaters","description":"一、题目描述 链接\n二、题目分析 有两个数组，一个数组代表house位置，另一个代表heater位置。这种类型题一般来说都是固定一个数组，遍历另一个数组。固定house，遍历heater明显不对。因为heater的相互位置没有考虑，结果一定偏大。以下图为例，两个数组分别为：[0, 3], [1, 2]，如果分别遍历1和2，则结果至少是2，实际应该是1.所以应该固定heater，遍历house。\n思路确定之后，解法就很明显了。解法一：对每个house位置，用二分法找到最近的heater位置，最后取位置的最大值即为解，因为用了二分法，所以heater数组需要先进行排序。解法二：把house和heater两个数组都进行排序，然后遍历house，每次记住最近的heater位置，下次遍历时从记住的位置开始，最后取位置最大值为解。\n三、代码 解法一： heaters.sort() res = 0 for house in houses: start = 0 end = len(heaters) - 1 while start \u002b 1 \u0026amp;lt; end: mid = start \u002b (end - start) \/ 2 if heaters[mid] \u0026gt; house: end = mid else: start = mid res = max(res, min(abs(house - heaters[start]), abs(heaters[end] - house))) return res 解法二： houses.sort() heaters.sort() i, res = 0, 0 for house in houses: while i \u0026amp;lt; len(heaters) - 1 and heaters[i] \u002b heaters[i \u002b 1] \u0026amp;lt;= house * 2: i \u002b= 1 res = max(res, abs(heaters[i] - house)) return res ","inLanguage":"en-US","author":"Fan Jingbo","creator":"Fan Jingbo","publisher":"Fan Jingbo","accountablePerson":"Fan Jingbo","copyrightHolder":"Fan Jingbo","copyrightYear":"2018","datePublished":"2018-02-05 01:44:15 \u002b0800 CST","dateModified":"2018-02-05 01:44:15 \u002b0800 CST","url":"https:\/\/fanjingbo.com\/post\/leetcode_heaters\/","keywords":[]}</script><title>[Leetcode] Heaters - Fan Jingbo's Blog</title><meta property="og:title" content="[Leetcode] Heaters - Fan Jingbo's Blog"><meta property="og:type" content="article"><meta property="og:description" content="一、题目描述 链接
二、题目分析 有两个数组，一个数组代表house位置，另一个代表heater位置。这种类型题一般来说都是固定一个数组，遍历另一个数组。固定house，遍历heater明显不对。因为heater的相互位置没有考虑，结果一定偏大。以下图为例，两个数组分别为：[0, 3], [1, 2]，如果分别遍历1和2，则结果至少是2，实际应该是1.所以应该固定heater，遍历house。
思路确定之后，解法就很明显了。解法一：对每个house位置，用二分法找到最近的heater位置，最后取位置的最大值即为解，因为用了二分法，所以heater数组需要先进行排序。解法二：把house和heater两个数组都进行排序，然后遍历house，每次记住最近的heater位置，下次遍历时从记住的位置开始，最后取位置最大值为解。
三、代码 解法一： heaters.sort() res = 0 for house in houses: start = 0 end = len(heaters) - 1 while start + 1 &amp;lt; end: mid = start + (end - start) / 2 if heaters[mid] > house: end = mid else: start = mid res = max(res, min(abs(house - heaters[start]), abs(heaters[end] - house))) return res 解法二： houses.sort() heaters.sort() i, res = 0, 0 for house in houses: while i &amp;lt; len(heaters) - 1 and heaters[i] + heaters[i + 1] &amp;lt;= house * 2: i += 1 res = max(res, abs(heaters[i] - house)) return res "><meta name=description content="一、题目描述 链接
二、题目分析 有两个数组，一个数组代表house位置，另一个代表heater位置。这种类型题一般来说都是固定一个数组，遍历另一个数组。固定house，遍历heater明显不对。因为heater的相互位置没有考虑，结果一定偏大。以下图为例，两个数组分别为：[0, 3], [1, 2]，如果分别遍历1和2，则结果至少是2，实际应该是1.所以应该固定heater，遍历house。
思路确定之后，解法就很明显了。解法一：对每个house位置，用二分法找到最近的heater位置，最后取位置的最大值即为解，因为用了二分法，所以heater数组需要先进行排序。解法二：把house和heater两个数组都进行排序，然后遍历house，每次记住最近的heater位置，下次遍历时从记住的位置开始，最后取位置最大值为解。
三、代码 解法一： heaters.sort() res = 0 for house in houses: start = 0 end = len(heaters) - 1 while start + 1 &amp;lt; end: mid = start + (end - start) / 2 if heaters[mid] > house: end = mid else: start = mid res = max(res, min(abs(house - heaters[start]), abs(heaters[end] - house))) return res 解法二： houses.sort() heaters.sort() i, res = 0, 0 for house in houses: while i &amp;lt; len(heaters) - 1 and heaters[i] + heaters[i + 1] &amp;lt;= house * 2: i += 1 res = max(res, abs(heaters[i] - house)) return res "><meta property="og:locale" content="en-us"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Fan Jingbo's Blog"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif&display=swap" rel=stylesheet></head><body><article class="post Chinese" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Fan Jingbo</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>[Leetcode] Heaters</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2018-02-05 01:44:15 CST">05 Feb 2018</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://fanjingbo.com>@Fan Jingbo</a></div></div></div></header><div class="post-content markdown-body"><h2 id=一题目描述>一、题目描述</h2><p><a href=https://leetcode.com/problems/heaters/description/>链接</a></p><h2 id=二题目分析>二、题目分析</h2><p>有两个数组，一个数组代表house位置，另一个代表heater位置。这种类型题一般来说都是<strong>固定一个数组，遍历另一个数组</strong>。固定house，遍历heater明显不对。因为heater的相互位置没有考虑，结果一定偏大。以下图为例，两个数组分别为：[0, 3], [1, 2]，如果分别遍历1和2，则结果至少是2，实际应该是1.所以应该固定heater，遍历house。</p><p>思路确定之后，解法就很明显了。解法一：对每个house位置，用二分法找到最近的heater位置，最后取位置的最大值即为解，因为用了二分法，所以heater数组需要先进行排序。解法二：把house和heater两个数组都进行排序，然后遍历house，每次记住最近的heater位置，下次遍历时从记住的位置开始，最后取位置最大值为解。</p><h2 id=三代码>三、代码</h2><h3 id=解法一>解法一：</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>heaters<span style=color:#f92672>.</span>sort()
res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
<span style=color:#66d9ef>for</span> house <span style=color:#f92672>in</span> houses:
    start <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
    end <span style=color:#f92672>=</span> len(heaters) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
    <span style=color:#66d9ef>while</span> start <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;</span>lt; end:
        mid <span style=color:#f92672>=</span> start <span style=color:#f92672>+</span> (end <span style=color:#f92672>-</span> start) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
        <span style=color:#66d9ef>if</span> heaters[mid] <span style=color:#f92672>&gt;</span> house:
            end <span style=color:#f92672>=</span> mid
        <span style=color:#66d9ef>else</span>:
            start <span style=color:#f92672>=</span> mid
    res <span style=color:#f92672>=</span> max(res, min(abs(house <span style=color:#f92672>-</span> heaters[start]), abs(heaters[end] <span style=color:#f92672>-</span> house)))
<span style=color:#66d9ef>return</span> res
</code></pre></div><h3 id=解法二>解法二：</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>houses<span style=color:#f92672>.</span>sort()
heaters<span style=color:#f92672>.</span>sort()
i, res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
<span style=color:#66d9ef>for</span> house <span style=color:#f92672>in</span> houses:
    <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&amp;</span>lt; len(heaters) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>and</span> heaters[i] <span style=color:#f92672>+</span> heaters[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>&amp;</span>lt;<span style=color:#f92672>=</span> house <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>:
        i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
    res <span style=color:#f92672>=</span> max(res, abs(heaters[i] <span style=color:#f92672>-</span> house))
<span style=color:#66d9ef>return</span> res
</code></pre></div></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=site-footer><div class=site-footer-item><a href=http://beian.miit.gov.cn target=_blank>粤ICP备18020202号-1</a></div><div class=site-footer-item><a href=https://github.com/flyingpot target=_blank>Github</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad()</script></body></html>