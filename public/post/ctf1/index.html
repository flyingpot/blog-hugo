<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.82.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Fan Jingbo"><meta property="og:url" content="https://fanjingbo.com/post/ctf1/"><link rel=canonical href=https://fanjingbo.com/post/ctf1/><link rel=preload href=/js/highlight.pack.js as=script><link rel=alternate type=application/atom+xml href=https://fanjingbo.comindex.xml title="Fan Jingbo's Blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/fanjingbo.com"},"articleSection":"post","name":"CTF从零单排（一）—— collision (pwnable.kr)","headline":"CTF从零单排（一）—— collision (pwnable.kr)","description":"一、前言 最近突然对CTF产生了兴趣，感觉能从中学到很多东西。并且我发现很多关于CTF的解法文章对我这样的小白很不友好，因此我打算新开一坑，从零基础的角度详细地记录一下CTF的题解。\n二、题目及分析 今天做的题目是pwnable.kr里面的第二题——collision（第一题比较简单，就直接跳过了）。先是用ssh连到一个提供的主机上，发现目录下有三个文件。 col.c的代码如下：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt;unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i\u0026lt;5; i\u002b\u002b){ res \u002b= ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc\u0026lt;2){ printf(\u0026#34;usage : %s [passcode]\\n\u0026#34;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(\u0026#34;passcode length should be 20 bytes\\n\u0026#34;); return 0; } if(hashcode == check_password( argv[1] )){ system(\u0026#34;\/bin\/cat flag\u0026#34;); return 0; } else printf(\u0026#34;wrong passcode.","inLanguage":"en-US","author":"Fan Jingbo","creator":"Fan Jingbo","publisher":"Fan Jingbo","accountablePerson":"Fan Jingbo","copyrightHolder":"Fan Jingbo","copyrightYear":"2019","datePublished":"2019-03-11 16:00:00 \u002b0000 UTC","dateModified":"2019-03-11 16:00:00 \u002b0000 UTC","url":"https:\/\/fanjingbo.com\/post\/ctf1\/","keywords":[]}</script><title>CTF从零单排（一）—— collision (pwnable.kr) - Fan Jingbo's Blog</title><meta property="og:title" content="CTF从零单排（一）—— collision (pwnable.kr) - Fan Jingbo's Blog"><meta property="og:type" content="article"><meta property="og:description" content="一、前言 最近突然对CTF产生了兴趣，感觉能从中学到很多东西。并且我发现很多关于CTF的解法文章对我这样的小白很不友好，因此我打算新开一坑，从零基础的角度详细地记录一下CTF的题解。
二、题目及分析 今天做的题目是pwnable.kr里面的第二题——collision（第一题比较简单，就直接跳过了）。先是用ssh连到一个提供的主机上，发现目录下有三个文件。 col.c的代码如下：
#include <stdio.h>#include <string.h>unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i<5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc<2){ printf(&#34;usage : %s [passcode]\n&#34;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(&#34;passcode length should be 20 bytes\n&#34;); return 0; } if(hashcode == check_password( argv[1] )){ system(&#34;/bin/cat flag&#34;); return 0; } else printf(&#34;wrong passcode."><meta name=description content="一、前言 最近突然对CTF产生了兴趣，感觉能从中学到很多东西。并且我发现很多关于CTF的解法文章对我这样的小白很不友好，因此我打算新开一坑，从零基础的角度详细地记录一下CTF的题解。
二、题目及分析 今天做的题目是pwnable.kr里面的第二题——collision（第一题比较简单，就直接跳过了）。先是用ssh连到一个提供的主机上，发现目录下有三个文件。 col.c的代码如下：
#include <stdio.h>#include <string.h>unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i<5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc<2){ printf(&#34;usage : %s [passcode]\n&#34;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(&#34;passcode length should be 20 bytes\n&#34;); return 0; } if(hashcode == check_password( argv[1] )){ system(&#34;/bin/cat flag&#34;); return 0; } else printf(&#34;wrong passcode."><meta property="og:locale" content="en-us"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Fan Jingbo's Blog"><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif&display=swap" rel=stylesheet></head><body><article class="post Chinese" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Fan Jingbo</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>CTF从零单排（一）—— collision (pwnable.kr)</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2019-03-11 16:00:00 UTC">11 Mar 2019</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://fanjingbo.com>@Fan Jingbo</a></div></div></div></header><div class="post-content markdown-body"><h1 id=一前言>一、前言</h1><p>最近突然对CTF产生了兴趣，感觉能从中学到很多东西。并且我发现很多关于CTF的解法文章对我这样的小白很不友好，因此我打算新开一坑，从零基础的角度详细地记录一下CTF的题解。</p><h1 id=二题目及分析>二、题目及分析</h1><p>今天做的题目是pwnable.kr里面的第二题——collision（第一题比较简单，就直接跳过了）。先是用ssh连到一个提供的主机上，发现目录下有三个文件。
<img src=/images/ls-l.png alt>
col.c的代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> hashcode <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x21DD09EC</span>;
<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>check_password</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> p){
        <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> ip <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)p;
        <span style=color:#66d9ef>int</span> i;
        <span style=color:#66d9ef>int</span> res<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>for</span>(i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>){
                res <span style=color:#f92672>+=</span> ip[i];
        }
        <span style=color:#66d9ef>return</span> res;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> argv[]){
        <span style=color:#66d9ef>if</span>(argc<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>){
                printf(<span style=color:#e6db74>&#34;usage : %s [passcode]</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>0</span>]);
                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        }
        <span style=color:#66d9ef>if</span>(strlen(argv[<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>20</span>){
                printf(<span style=color:#e6db74>&#34;passcode length should be 20 bytes</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        }

        <span style=color:#66d9ef>if</span>(hashcode <span style=color:#f92672>==</span> check_password( argv[<span style=color:#ae81ff>1</span>] )){
                system(<span style=color:#e6db74>&#34;/bin/cat flag&#34;</span>);
                <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        }
        <span style=color:#66d9ef>else</span>
                printf(<span style=color:#e6db74>&#34;wrong passcode.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>我们可以看到最后是调用cat命令读取flag文件。而我们的当前用户如下图所示： <img src=/images/id.png alt></p><p>那么到底为什么用户不能直接读取flag文件而通过col这个可执行文件就能读取呢？</p><h1 id=三文件系统权限>三、文件系统权限</h1><p>回忆一下文件系统权限：第一位是文件类型，一般常见的就两种，-代表普通文件，d代表目录。其实还有很多别的类型，通过以下命令可以看到：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>info ls <span style=color:#e6db74>&#34;What information is listed&#34;</span>
</code></pre></div><p>后面一共九位，可以被分为三组，代表文件拥有者权限，群组权限和其他用户权限。每一组按顺序分别代表读(Read)，写(Write)和执行(Execute)。对于读和写比较简单，r或w代表可读或可写，-代表不可读(写)。执行位除了x(可执行)和-(不可执行)外，还有其他可能，常见的就是s。s代表x被激活，另外只可能出现在前两组里面，分别被称为setuid和setgid。当可执行文件被设置setuid或setgid时，可执行文件拥有的权限是可执行文件的文件拥有者或群组权限，而不是当前的用户或者群组所拥有的权限。</p><p>说起来挺绕口，但其实很好理解，拿这道题举例子来串联上面的所有知识：当前用户属于col群组，而col可执行文件的群组权限是x，也属于col群组，所以当前用户可以执行col文件，而又因为col的setuid被激活，执行col文件相当于col_pwn这个用户执行col文件，而flag文件又是属于col_pwn用户的，所以运行col文件可以读取flag文件的内容。</p><h1 id=四字节序>四、字节序</h1><p>接下来看看题目要我们做什么，我们只需要让<code>check_password(argv[1])</code>等于<code>hashcode</code>即可。而在<code>check_password</code>函数中有强制类型转换，这就牵扯到了字节序的问题。</p><p>字节序有几个很容易让人疑惑的地方，但是经过总结，我认为只要理解了下面这段话，所有疑惑都会迎刃而解：</p><blockquote><p>字节序只影响占用多个字节的对象，并且只有在以下三种情况需要注意字节序：（1）不同字节序的机器传递数据时（2）阅读和检查机器级程序或查看数据在内存中的存储方式时（3）编写规避正常类型系统的程序时（如强制类型转换）</p></blockquote><p>而实际上前两种情况我们基本不用考虑，最常见的就是第三种情况。</p><p>下面是两个常见的问题，看看是不是能用这句话轻松解决：</p><ol><li>字节序对于数组是怎么影响的？<a href=https://stackoverflow.com/questions/26455843/how-are-array-values-stored-in-little-endian-vs-big-endian-architecture>示例1</a></li></ol><p>数组每个元素的顺序是与字节序无关的，<code>array[1]</code>永远在<code>array[0]</code>一个<code>sizeof(*array)</code>之后的位置。如果数组中的元素含有多个字节，那么这个元素在内存中的存储方式会受到字节序的影响。</p><ol><li>字节序对于指针是怎么影响的，指针指向的是最高有效位(MSB)还是最低有效位(LSB)？<a href=https://stackoverflow.com/questions/11985399/does-a-pointer-point-to-the-lsb-or-msb>示例2</a></li></ol><p>与数组相似，取地址永远取的是低地址，对于占用多个字节的变量指针来说，小端字节序指针指向的是最低有效位，大端字节序指针指向的是最高有效位。</p><p>接下来我们举一个强制类型转换的例子对字节序进行说明：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>a <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1234&#34;</span>;
	<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>b <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)a;
	printf(<span style=color:#e6db74>&#34;%#010x</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>*</span>b);
}
</code></pre></div><p>在这个例子中，变量<code>a</code>是一个字符串指针，每一个<code>char</code>对应一个字节，共有四个字节，<code>a</code>指向的地址是<code>1</code>对应的地址。将“1234”这个字符串对照ASCII表可以转化成十六进制表示0x31323334.</p><p><code>a</code>经过强制类型转换变成了整型指针<code>b</code>，同样整型也是4个字节，这时计算机是怎么读取整型数取决于字节序。读取过程是这样的：首先找到地址，对应0x31这个值，接下来如果是大端字节序，那么向高地址读取4个字节，对应0x31323334，如果是小端字节序，那么向低地址读取4个字节，对应0x34333231.</p><p>在我的电脑上运行如上代码，结果为0x34333231，说明电脑是小端字节序。Python中查看字节序的方法如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> sys
<span style=color:#66d9ef>print</span>(sys<span style=color:#f92672>.</span>byteorder)
</code></pre></div><h1 id=四解题思路>四、解题思路</h1><p>现在回到题目中，输入一个20个字节长的字符串，做整型的强制类型转换，每4个字节变为一个整型数，将5个整型数累加得到指定值0x21DD09EC。一个最简单的想法是，将原来的数0x21DD09EC与4个零值累加。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>python -c <span style=color:#e6db74>&#34;print &#39;\x00\x00\x00\x00&#39;*4 + &#39;\xec\x09\xdd\x21&#39;&#34;</span>
</code></pre></div><p>使用上面的单行脚本可以生成<code>col</code>的标准输入<code>argv[1]</code></p><p><img src=/images/python-c.png alt></p><p>因此：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>./col <span style=color:#e6db74>`</span>python -c <span style=color:#e6db74>&#34;print &#39;\x00\x00\x00\x00&#39;*4 + &#39;\xec\x09\xdd\x21&#39;&#34;</span><span style=color:#e6db74>`</span>
</code></pre></div><p>注意由于是小端字节序，0x21DD09EC要写成0xEC09DD21。上面的符号`代表命令替换，使用括起来命令的标准输出作为替换。</p><p>但是我们会发现出现了错误提示"passcode length should be 20 bytes"。原因在于0x00代表了null，并且作为字符串的结束符使用，因此读入的字符串会被截断，出现错误输出。</p><p>那既然0x00不行，那我们就用0x01代替，则：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>&gt;&gt;&gt;</span> hex(<span style=color:#ae81ff>0x21DD09EC</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0x01010101</span><span style=color:#f92672>*</span><span style=color:#ae81ff>4</span>)
<span style=color:#e6db74>&#39;0x1dd905e8&#39;</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>./col <span style=color:#e6db74>`</span>python -c <span style=color:#e6db74>&#34;print &#39;\x01\x01\x01\x01&#39;*4 + &#39;\xe8\x05\xd9\x1d&#39;&#34;</span><span style=color:#e6db74>`</span>
</code></pre></div><p>大功告成，成功拿到flag。</p><h4 id=参考链接>参考链接</h4><ol><li><a href=https://wiki.archlinux.org/index.php/File_permissions_and_attributes> File Permissions and Attributes </a></li><li><a href=https://en.wikipedia.org/wiki/Setuid>Setuid</a></li><li><a href=https://book.douban.com/subject/1896753/>深入理解计算机系统</a></li><li><a href=https://unix.stackexchange.com/questions/27428/what-does-backquote-backtick-mean-in-commands>What does ` (backquote/backtick) mean in commands?</a></li></ol></div><div class="row middle-xs"><div class=col-xs-12></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><div class=site-footer><div class=site-footer-item><a href=http://beian.miit.gov.cn target=_blank>粤ICP备18020202号-1</a></div><div class=site-footer-item><a href=https://github.com/flyingpot target=_blank>Github</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad()</script></body></html>