<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.74.3" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Fanjingbo" />
  <meta property="og:url" content="https://fanjingbo.com/post/boyer_moore_majority_vote/" />
  <link rel="canonical" href="https://fanjingbo.com/post/boyer_moore_majority_vote/" /><script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/fanjingbo.com"
      },
      "articleSection" : "post",
      "name" : "Boyer-Moore Majority Vote算法及相关算法题",
      "headline" : "Boyer-Moore Majority Vote算法及相关算法题",
      "description" : "一、算法简介 Boyer-Moore Majority Vote算法（以下简称BMMV算法）是用来在一系列元素中查找主要元素的算法，具有O(n)的时间复杂度和O(1)的空间复杂度。该算法在1981年由Robert S. Boyer和J Strother Moore提出。\n Tips: Robert S. Boyer和J Strother Moore两人在1977年提出了Boyer-Moore字符串搜索算法，也是一个很经典的算法\n 二、问题描述 1. Leetcode 169 (Majority Element)  给定含有n个元素的数组，寻找其主元素（出现超过n\/2下界次的元素）\n 题解： 本题有多种解法，排序，哈希表都可以AC。先说一下比较巧妙的排序法。\nclass Solution: def majorityElement(self, nums): return sorted(nums)[len(nums)\/\/2] 主要原理就是，只要主元素存在，数组索引为len(nums)\/\/2处的值一定是主元素（对于奇数长度的数组，中位数一定是主元素；对于偶数长度的数组，中间的两个数一定都是主元素）。\n哈希表的方法见下文。\n下面是BMMV算法的实现代码：\nclass Solution: def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count \u002b= (1 if num == candidate else -1) return candidate 可以看出，BMMV算法思想很简单，初始化count为0，每当count为0时，candidate为数组中下一个数，遍历数组，如果数等于candidate，则count加一，否则减一，最后返回candidate即为主元素",
      "inLanguage" : "en-US",
      "author" : "Fanjingbo",
      "creator" : "Fanjingbo",
      "publisher": "Fanjingbo",
      "accountablePerson" : "Fanjingbo",
      "copyrightHolder" : "Fanjingbo",
      "copyrightYear" : "2017",
      "datePublished": "2017-11-24 04:35:46 \u002b0000 \u002b0000",
      "dateModified" : "2017-11-24 04:35:46 \u002b0000 \u002b0000",
      "url" : "https:\/\/fanjingbo.com\/post\/boyer_moore_majority_vote\/",
      "keywords" : [  ]
  }
</script>
<title>Boyer-Moore Majority Vote算法及相关算法题 - Fan Jingbo&#39;s Blog</title>
  <meta property="og:title" content="Boyer-Moore Majority Vote算法及相关算法题 - Fan Jingbo&#39;s Blog" />
  <meta property="og:type" content="article" />
  <meta name="description" content="一、算法简介 Boyer-Moore Majority Vote算法（以下简称BMMV算法）是用来在一系列元素中查找主要元素的算法，具有O(n)的时间复杂度和O(1)的空间复杂度。该算法在1981年由Robert S. Boyer和J Strother Moore提出。
 Tips: Robert S. Boyer和J Strother Moore两人在1977年提出了Boyer-Moore字符串搜索算法，也是一个很经典的算法
 二、问题描述 1. Leetcode 169 (Majority Element)  给定含有n个元素的数组，寻找其主元素（出现超过n/2下界次的元素）
 题解： 本题有多种解法，排序，哈希表都可以AC。先说一下比较巧妙的排序法。
class Solution: def majorityElement(self, nums): return sorted(nums)[len(nums)//2] 主要原理就是，只要主元素存在，数组索引为len(nums)//2处的值一定是主元素（对于奇数长度的数组，中位数一定是主元素；对于偶数长度的数组，中间的两个数一定都是主元素）。
哈希表的方法见下文。
下面是BMMV算法的实现代码：
class Solution: def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count &#43;= (1 if num == candidate else -1) return candidate 可以看出，BMMV算法思想很简单，初始化count为0，每当count为0时，candidate为数组中下一个数，遍历数组，如果数等于candidate，则count加一，否则减一，最后返回candidate即为主元素" />

  <link rel="stylesheet" href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css" />
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="Fan Jingbo&#39;s Blog">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker" rel="stylesheet">
  
  <script>
    

    (function (undefined) { }).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});
  </script>

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-132076423-1"></script><script src="https://fanjingbo.com/analytics.js"></script>
</head>

<body>
  <article class="post Chinese" id="article">
    <div class="row">
      <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2 col-lg-6 col-lg-offset-3">
        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <a href="/">Fanjingbo</a>
  </div>
</header>
<div class="row end-xs">
  
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">Boyer-Moore Majority Vote算法及相关算法题</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2017-11-24 04:35:46 &#43;0000">
                24 Nov 2017
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="https://fanjingbo.com">@Fanjingbo</a>
              </div>
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          <h2 id="一算法简介">一、算法简介</h2>
<p>Boyer-Moore Majority Vote算法（以下简称BMMV算法）是用来在一系列元素中查找主要元素的算法，具有O(n)的时间复杂度和O(1)的空间复杂度。该算法在1981年由Robert S. Boyer和J Strother Moore提出。</p>
<blockquote>
<p>Tips: Robert S. Boyer和J Strother Moore两人在1977年提出了Boyer-Moore字符串搜索算法，也是一个很经典的算法</p>
</blockquote>
<h2 id="二问题描述">二、问题描述</h2>
<h3 id="1-leetcode-169-majority-element">1. Leetcode 169 (Majority Element)</h3>
<blockquote>
<p>给定含有n个元素的数组，寻找其主元素（出现超过n/2下界次的元素）</p>
</blockquote>
<h4 id="题解"><strong>题解：</strong></h4>
<p>本题有多种解法，排序，哈希表都可以AC。先说一下比较巧妙的排序法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">majorityElement</span>(self, nums):
      <span style="color:#66d9ef">return</span> sorted(nums)[len(nums)<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>]
</code></pre></div><p>主要原理就是，只要主元素存在，数组索引为len(nums)//2处的值一定是主元素（对于奇数长度的数组，中位数一定是主元素；对于偶数长度的数组，中间的两个数一定都是主元素）。</p>
<p>哈希表的方法见下文。</p>
<p>下面是BMMV算法的实现代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">majorityElement</span>(self, nums):
      count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
      candidate <span style="color:#f92672">=</span> None

      <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> nums:
          <span style="color:#66d9ef">if</span> count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
              candidate <span style="color:#f92672">=</span> num
          count <span style="color:#f92672">+=</span> (<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> num <span style="color:#f92672">==</span> candidate <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
            
      <span style="color:#66d9ef">return</span> candidate
</code></pre></div><p>可以看出，BMMV算法思想很简单，初始化count为0，每当count为0时，candidate为数组中下一个数，遍历数组，如果数等于candidate，则count加一，否则减一，最后返回candidate即为主元素</p>
<h3 id="2-leetcode-229-majority-element-ii">2. Leetcode 229 (Majority Element II)</h3>
<blockquote>
<p>给定含有n个元素的数组，寻找所有出现超过n/3下界次的元素</p>
</blockquote>
<h4 id="题解-1"><strong>题解：</strong></h4>
<blockquote>
<p>Tips: 最多存在两个所求元素</p>
</blockquote>
<p>BMMV算法代码如下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">majorityElement</span>(self, nums):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
            <span style="color:#66d9ef">return</span> []
        count1, count2, candidate1, candidate2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, None, None
        <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> nums:
            <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> candidate1:
                count1 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">elif</span> n <span style="color:#f92672">==</span> candidate2:
                count2 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">elif</span> count1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                candidate1, count1 <span style="color:#f92672">=</span> n, <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">elif</span> count2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                candidate2, count2 <span style="color:#f92672">=</span> n, <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                count1, count2 <span style="color:#f92672">=</span> count1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, count2 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> [n <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> (candidate1, candidate2)
                        <span style="color:#66d9ef">if</span> nums<span style="color:#f92672">.</span>count(n) <span style="color:#f92672">&gt;</span> len(nums) <span style="color:#f92672">//</span> <span style="color:#ae81ff">3</span>]
</code></pre></div><p>类似上一题，由于最多两个元素，所以设两个count和candidate，遍历数组，最后验证两个candidate是否满足题意</p>
<p>本题依旧可以用哈希表求解，代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">majorityElement</span>(self, nums):
        count <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>Counter(nums)
        <span style="color:#66d9ef">return</span> [key <span style="color:#66d9ef">for</span> (key, value) <span style="color:#f92672">in</span> count<span style="color:#f92672">.</span>items() <span style="color:#66d9ef">if</span> value <span style="color:#f92672">&gt;</span> len(nums) <span style="color:#f92672">//</span> <span style="color:#ae81ff">3</span>]
</code></pre></div><h2 id="三总结">三、总结</h2>
<p>BMMV算法可以看做是主元素相关问题的特解，而如果主元素个数要求变到n/k的话，使用BMMV算法无法写出一个通解。这时哈希表可以作为一种通解。</p>
<h3 id="ps">P.S.</h3>
<p>Lintcode类似题的主元素个数的下界分别为n/2、n/3、n/k，并且加上了条件&rsquo;There is only one majority number in the array&rsquo;，这么一改题目立马变得很low，因为只要找到数组中出现最多的元素就可以了，代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">majorityElement</span>(self, nums):
        counts <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>Counter(nums)
        <span style="color:#66d9ef">return</span> max(counts<span style="color:#f92672">.</span>keys(), key<span style="color:#f92672">=</span>counts<span style="color:#f92672">.</span>get)
</code></pre></div><h4 id="参考链接">参考链接</h4>
<p>1.<a href="https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html">Majority Voting Algorithm</a></p>
<p>2.<a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm">Boyer–Moore majority vote algorithm (Wiki)</a></p>

        </div>
        

        


        
        
        <div style="height: 50px;"></div>
        
        <div class="post-comments">
          <div id="disqus_thread"></div>
<script>
  window.addEventListener("load", () => {
    (function() {
      
      var d = document,
        s = d.createElement("script");
      s.src = "https://fanjingbo-com.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  });
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>

        </div>
        
        

        <div class="site-footer">
  
  <div class="site-footer-item">
    <a href="http://beian.miit.gov.cn" target="_blank">粤ICP备18020202号-1</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://github.com/flyingpot" target="_blank">Github</a>
  </div>
  
  
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>
<script src="https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js"></script>

<script>
  hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });
</script>

  

</body>

</html>